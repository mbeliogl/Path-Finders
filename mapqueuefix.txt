As a multithreaded program, mapqueue is bound to run into some issues when multiple threads attempt to access (and write) the same piece of memory. In mapqueue this problems could occur in the following circumstance: upon checking whether the queue is empty, the program "pops" an element (job) and then perfroms appropriate operations with it. Namely, it outputs the information about the job into the terminal. And because it is not an atomic operation, it takes some time to do. This creates a condition known as "race condition". Multiple threads pop the same thing from the queue and then some of them attempt to perform operations with it simultaniously. This trggers unsensible behavior. 

To combat this problem I took use of the mutex lock() and unlock() functionality. In takeJobs() I have commanded the worker thread to wait for the mutex to be uncloked and then take ownership of it. Then, the thread performs the prints and unclocks the mutex for the next thread in line. This implementation ensures that at no time do two or more threads attemts to work on the same piece of memory (the same job). As locking and unlocking are atomic operations, there is no issue with employing them to regulate the behavior of the threads. 